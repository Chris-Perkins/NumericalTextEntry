//
//  UIAnimatedFittedFlatNumberDisplayer.swift
//  NumericalTextField
//
//  Created by Christopher Perkins on 8/4/18.
//

/// A UINumberDisplayer that simply displays all of the numbers within fitted UILabels.
open class UIFittedFlatNumberDisplayer: UINumberDisplayer {
    /// The amount of time it takes in seconds for the animation of a number scrub to complete.
    private static let animationTime: CFTimeInterval = 0.2
    
    /// The alpha that determines if something is hidden.
    private static let hiddenAlphaOpacity: CGFloat = 0
    
    /// The weight of a string when determining string total width/height.
    private static let stringWeight: CGFloat = 1.0
    
    /// The height of the grouping separator fade height.
    private static let nonNumericFadeHeightMultiplier: CGFloat = 1.0 / 4.0
    
    /// The height of the number fade height.
    private static let numberFadeHeightMultiplier: CGFloat = 1.0 / 2.0
    
    /// The alpha component of faded colors.
    private static let fadedColorAlpha: CGFloat = 0.25
    
    /// Whether or not this number displayer is animated.
    public var animated: Bool = true
    
    /// The font that the label should use.
    private let font: UIFont
    
    /// The text color of the label.
    private let textColor: UIColor
    
    /// The UISingleNumberDisplayer labels sorted in ascending order of their index
    private var numberLabelsWithIndex = [(UISingleCharacterNumberDisplayerLabel, Int)]()
    
    /// The GroupingSeparator labels sorted in ascending order of their index
    private var nonNumericLabelWithIndex = [(UISingleCharacterNumberDisplayerLabel, Int)]()
    
    /// Initializes this number displayer with the provided font and fontColor
    ///
    /// - Parameters:
    ///   - font: the font for the displayer
    ///   - fontColor: the color of the font for the displayer
    /* Note: font size of 12.0 does nothing; is overriden later. We only care about system font. */
    public init(withFont font: UIFont = UIFont.systemFont(ofSize: 12.0),
                withTextColor textColor: UIColor = UIColor.black) {
        self.font = font
        self.textColor = textColor
    }
    
    /// Displays the input value within a single UILabel that is generated by this method.
    /// Characters in both the `stringToDisplay` and the `rawValue` are bolded, and characters that
    /// are not in both are given an opacity of 0.25.
    ///
    /// - Parameters:
    ///   - stringToDisplay: The complete string to display.
    ///   - rawValue: The raw value of the string to display (not formatted)
    ///   - numberFormatter: The formatter used to generate the stringToDisplay.
    ///   - view: The view where the value should be displayed in
    /// - Returns: The views that were created to hold the displayed value.
    open func displayValue(_ stringToDisplay: String, withRawString rawString: String,
                           numberFormatter: NumberFormatter,
                           inView view: UIView) -> [UIView] {
        createLabels(stringToDisplay, withRawString: rawString, numberFormatter: numberFormatter,
                     inView: view)
        constrainLabels(inView: view)
        
        var allLabels = [UIView]()
        allLabels.append(contentsOf: numberLabelsWithIndex.map({ (label, index) -> UIView in
            return label
        }))
        allLabels.append(contentsOf: nonNumericLabelWithIndex.map({ (label, index) -> UIView in
            return label
        }))
        
        return allLabels
    }
    
    /// Creates the labels that will be constrained later.
    ///
    /// - Parameters:
    ///   - stringToDisplay: The String to display
    ///   - rawString: The raw value of the string
    ///   - numberFormatter: The `NumberFormatter` used to create the stringToDisplay
    ///   - view: The view where the labels should be put inside
    private func createLabels(_ stringToDisplay: String, withRawString rawString: String,
                              numberFormatter: NumberFormatter, inView view: UIView) {
        // Gets the first index where the two strings differ; string length if no difference.
        let indexOfDiffering = NumberDisplayerUtils.getFirstIndexWhereStringsDoNotMatch(
            displayedString: stringToDisplay, rawValue: rawString,
            ignoredStrings: [numberFormatter.groupingSeparator, numberFormatter.currencySymbol])
            ?? stringToDisplay.count
        
        // Set up the fonts for when they're needed in the below for loops.
        let fontSize = getFontSizeForString(stringToDisplay, inView: view)
        let weightedFontSize = fontSize * UIFittedFlatNumberDisplayer.stringWeight
        
        /* Holds the current index that is being turned into a character; needed to determine
         if the string went into a default string and to get the current index in the displayed
         labels. */
        var currentParsedCharacterIndex = 0
        var currentNumberCount = 0
        var currentNonNumericCount = 0
        
        var remainingNonNumericLength = 0
        while currentParsedCharacterIndex < stringToDisplay.count {
            let currentStringIndex = stringToDisplay.index(
                stringToDisplay.startIndex, offsetBy: currentParsedCharacterIndex)
            
            if remainingNonNumericLength == 0 {
                let displayedSuffixAfterIndex =
                    stringToDisplay[currentStringIndex..<stringToDisplay.endIndex]
                if displayedSuffixAfterIndex.hasPrefix(numberFormatter.groupingSeparator) {
                    remainingNonNumericLength = numberFormatter.groupingSeparator.count
                } else if displayedSuffixAfterIndex.hasPrefix(numberFormatter.decimalSeparator) {
                    remainingNonNumericLength = numberFormatter.decimalSeparator.count
                }
            }
            
            setupNumberLabel(withValue: stringToDisplay[currentStringIndex],
                             withFont: font.withSize(weightedFontSize),
                             atListIndex: remainingNonNumericLength > 0
                                ? currentNonNumericCount : currentNumberCount,
                             isDefaultText: currentParsedCharacterIndex >= indexOfDiffering,
                             type: remainingNonNumericLength > 0 ? .genericNonNumeric
                                : .genericNumeric,
                             displayIndex: currentParsedCharacterIndex)
            
            if remainingNonNumericLength > 0 {
                remainingNonNumericLength -= 1
                currentNonNumericCount += 1
            } else {
                currentNumberCount += 1
            }
            currentParsedCharacterIndex += 1
        }
        
        // If we have unused labels, we should remove them.
        if currentNumberCount <= numberLabelsWithIndex.count {
            for tuple in numberLabelsWithIndex[currentNumberCount..<numberLabelsWithIndex.count] {
                animateIfAnimatedThenRemoveFromSuperview(tuple.0)
            }
            numberLabelsWithIndex = Array(numberLabelsWithIndex[..<currentNumberCount])
        }
        if currentNonNumericCount <= nonNumericLabelWithIndex.count {
            for tuple in nonNumericLabelWithIndex[
                currentNonNumericCount..<nonNumericLabelWithIndex.count] {
                    animateIfAnimatedThenRemoveFromSuperview(tuple.0)
            }
            nonNumericLabelWithIndex =
                Array(nonNumericLabelWithIndex[..<currentNonNumericCount])
        }
    }
    
    /// Sets up a number label with the provided parameters. If a number label does not need to be
    /// created (in the case of an identical number label already existing at the provided index),
    /// then this does nothing. If a number label will be replaced, then the previous number label
    /// will scrub upwards to prepare for the new number label insertion.
    ///
    /// If this is default text, then the text will receive a slightly lucent text color.
    ///
    /// - Warning: Assumes type to only be of type `.genericNonNumeric` or `.genericNumeric`.
    /// Causes a fatalError otherwise.
    ///
    /// - Parameters:
    ///   - value: The value that the number label should have
    ///   - labelFont: The font that the number label should have
    ///   - listIndex: The index of insertion
    ///   - isDecimal: Whether or not this will represent a decimal label
    ///   - isDefaultText: Whether or not this is default text.
    private func setupNumberLabel(withValue value: Character, withFont labelFont: UIFont,
                                  atListIndex listIndex: Int, isDefaultText: Bool,
                                  type: UISingleCharacterNumberDisplayerLabel.type,
                                  displayIndex: Int) {
        if type != .genericNonNumeric && type != .genericNumeric {
            fatalError("The type input must be genericNonNumeric or genericNumeric.")
        }
        
        let characterString = String(describing: value)
        
        if type == .genericNonNumeric && listIndex < nonNumericLabelWithIndex.count {
            let labelAtIndex = nonNumericLabelWithIndex[listIndex].0
            if labelAtIndex.text == characterString && labelAtIndex.isDefaultText == isDefaultText {
                // Do nothing; text matches, no change in this text; just update the font + index.
                labelAtIndex.font = labelFont
                nonNumericLabelWithIndex[listIndex].1 = displayIndex
                return
            }
            // If we reached this point, we're going to change or remove the label.
            animateIfAnimatedThenRemoveFromSuperview(labelAtIndex)
        } else if type == .genericNumeric && listIndex < numberLabelsWithIndex.count {
            let labelAtIndex = numberLabelsWithIndex[listIndex].0
            if labelAtIndex.text == characterString && labelAtIndex.isDefaultText == isDefaultText {
                // Do nothing; text matches, no change in this text; just update the font + index.
                labelAtIndex.font = labelFont
                numberLabelsWithIndex[listIndex].1 = displayIndex
                return
            }
            // If we reached this point, we're going to change or remove the label.
            animateIfAnimatedThenRemoveFromSuperview(labelAtIndex)
        }
        
        // If this point was reached, then it becomes clear that we must set up the new label.
        let newLabel = UISingleCharacterNumberDisplayerLabel(labelType: type,
                                                             isDefaultText: isDefaultText)
        
        newLabel.text = characterString
        newLabel.textColor = isDefaultText
            ? textColor.withAlphaComponent(UIFittedFlatNumberDisplayer.fadedColorAlpha)
            : textColor
        newLabel.font = labelFont
        
        if type == .genericNonNumeric {
            if listIndex < nonNumericLabelWithIndex.count {
                nonNumericLabelWithIndex[listIndex] = (newLabel, displayIndex)
            } else {
                nonNumericLabelWithIndex.append((newLabel, displayIndex))
            }
        } else {
            if listIndex < numberLabelsWithIndex.count {
                numberLabelsWithIndex[listIndex] = (newLabel, displayIndex)
            } else {
                numberLabelsWithIndex.append((newLabel, displayIndex))
            }
        }
    }
    
    /// If animations are enabled, this causes the input label to scrub upwards and fade out.
    /// After animations complete, the label calls `removeFromSuperview()`. If animations are not
    /// enabled, this will skip animations and immediately call `removeFromSuperview()`.
    ///
    /// - Parameter label: The label to animate then remove.
    private func animateIfAnimatedThenRemoveFromSuperview(_ label:
        UISingleCharacterNumberDisplayerLabel) {
        if animated {
            // If we reached this point, then the label will be removed. Scrub previous label up
            let originalFrame = label.frame
            label.removeConstraints()
            label.translatesAutoresizingMaskIntoConstraints = true
            UIView.animate(withDuration: UIFittedFlatNumberDisplayer.animationTime) {
                if label.labelType == .genericNonNumeric {
                    label.frame = CGRect(x: originalFrame.minX,
                                         y: originalFrame.minY + label.frame.size.height
                                            * UIFittedFlatNumberDisplayer
                                                .nonNumericFadeHeightMultiplier,
                                         width: originalFrame.size.width,
                                         height: originalFrame.size.height)
                } else {
                    label.frame = CGRect(x: originalFrame.minX,
                                         y: originalFrame.minY - label.frame.size.height
                                            * UIFittedFlatNumberDisplayer
                                                .numberFadeHeightMultiplier,
                                         width: originalFrame.size.width,
                                         height: originalFrame.size.height)
                }
                label.alpha = UIFittedFlatNumberDisplayer.hiddenAlphaOpacity
            }
            
            Timer.scheduledTimer(withTimeInterval: UIFittedFlatNumberDisplayer.animationTime,
                                 repeats: false) { (timer) in
                                    label.removeFromSuperview()
            }
        } else {
            label.removeFromSuperview()
        }
    }
    
    /// Constrains all created labels within the provided view.
    ///
    /// - Parameter view: The view to constrain the labels inside
    private func constrainLabels(inView view: UIView) {
        var rightmostView = view
        var currentNumberLabelsTupleIndex = numberLabelsWithIndex.count - 1
        var currentGroupingSeparatorLabelsTupleIndex = nonNumericLabelWithIndex.count - 1
        
        while currentNumberLabelsTupleIndex >= 0 || currentGroupingSeparatorLabelsTupleIndex >= 0 {
            var labelToConstrain: UISingleCharacterNumberDisplayerLabel!
            if currentGroupingSeparatorLabelsTupleIndex < 0 {
                labelToConstrain = numberLabelsWithIndex[currentNumberLabelsTupleIndex].0
                currentNumberLabelsTupleIndex -= 1
            } else if currentNumberLabelsTupleIndex < 0 {
                labelToConstrain =
                    nonNumericLabelWithIndex[currentGroupingSeparatorLabelsTupleIndex].0
                currentGroupingSeparatorLabelsTupleIndex -= 1
            } else {
                let numberTuple = numberLabelsWithIndex[currentNumberLabelsTupleIndex]
                let groupingSeparatorTuple =
                    nonNumericLabelWithIndex[currentGroupingSeparatorLabelsTupleIndex]
                
                if numberTuple.1 > groupingSeparatorTuple.1 {
                    labelToConstrain = numberTuple.0
                    currentNumberLabelsTupleIndex -= 1
                } else {
                    labelToConstrain = groupingSeparatorTuple.0
                    currentGroupingSeparatorLabelsTupleIndex -= 1
                }
            }
            
            // Place the label in the correct position, attach constraints.
            if labelToConstrain.superview != view {
                labelToConstrain.removeFromSuperview()
                view.addSubview(labelToConstrain)
            } else {
                labelToConstrain.removeConstraints()
            }
            
            // Used to set the width of the number label
            let labelSize = labelToConstrain.text!.size(withAttributes:
                [NSAttributedStringKey.font : labelToConstrain.font])
            
            labelToConstrain.topEdgeConstraint = labelToConstrain.copy(.top, of: view)
            labelToConstrain.heightConstraint = labelToConstrain.copy(.height, of: view)
                .withMultiplier(UIFittedFlatNumberDisplayer.stringWeight)
            labelToConstrain.rightEdgeConstraint =
                labelToConstrain.cling(.right, to: rightmostView,
                                       rightmostView == view ? .right : .left)
            labelToConstrain.widthConstraint = labelToConstrain.setWidth(labelSize.width)
            
            rightmostView = labelToConstrain
        }
    }
}

extension UIFittedFlatNumberDisplayer: FittedStringDisplayer {
    /// Gets the font size given a string and view to fit in.
    ///
    /// - Parameters:
    ///   - string: input.
    ///   - view: The view to get the max font size for.
    /// - Returns: The unweighted font size to use to fit the view for the string.
    private func getFontSizeForString(_ string: String, inView view: UIView) -> CGFloat {
        let arrayOfCharactersWithWeights = getListOfCharactersWithWeight(
            string, withWeight: UIFittedFlatNumberDisplayer.stringWeight)
        return getSizeToFit(stringsWithWeights: arrayOfCharactersWithWeights,
                            font: font, maxSize: view.frame.size)
    }
    
    /// Create a list of individual characters to the input weight.
    ///
    /// - Parameters:
    ///   - characters: A string to convert to a list of characters
    ///   - weight: The weight for each character in the list
    /// - Returns: A list of tuples of single character strings and the provided weight.
    private func getListOfCharactersWithWeight(_ characters: String,
                                               withWeight weight: CGFloat) -> [(String, CGFloat)] {
        var charactersWithWeights = [(String, CGFloat)]()
        for character in characters {
            charactersWithWeights.append((String(describing: character), weight))
        }
        
        return charactersWithWeights
    }
}
